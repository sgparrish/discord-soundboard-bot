const { ActionRowBuilder, ButtonBuilder, ButtonStyle } = require("discord.js");

const Persistence = require("../persistence");

const BaseDiscordService = require("./basediscordservice");

class UserChannel extends BaseDiscordService {
  constructor() {
    super();
    this.busy = false;

    this.isConsentMenu = this._isConsentMenu.bind(this);
  }

  // #region Event Handlers
  async onReady(client, server) {
    this.client = client;
    this.server = server;

    this.mutedByMe = [];

    // set up event handlers
    this.client.on("voiceStateUpdate", this.onVoiceStateUpdpate.bind(this));
    this.client.on("interactionCreate", this.onInteractionCreate.bind(this));

    Persistence.on(Persistence.events.consent.granted, this.onConsentChange.bind(this));
    Persistence.on(Persistence.events.consent.revoked, this.onConsentChange.bind(this));
  }

  async onVoiceStateUpdpate(oldState, newState) {
    // mark as busy so we can ignore all the updates generated by muting
    if (this.busy) return;
    this.busy = true;

    const voiceMembers = await this.getVoiceMembers();

    // send out consent forms to everyone
    await Promise.all(voiceMembers.map((member) => this.buildConsentMenu(member)));

    const memberConsent = await Promise.all(voiceMembers.map((member) => Persistence.getConsent(member.id)));

    const unconsentingMembers = voiceMembers.filter(
      (member) =>
        !memberConsent.some((consent) => consent && consent.userId === member.id && consent.status === "granted")
    );

    // mute people who haven't consented
    await Promise.allSettled(
      unconsentingMembers
        .filter((member) => !member.voice.serverMute)
        .map((member) => {
          this.mutedByMe.push(member.id);
          member.voice.setMute(true);
        })
    );

    this.busy = false;
  }

  async onInteractionCreate(interaction) {
    if (interaction.isButton()) {
      const parts = interaction.customId.split(".");
      if (parts[0] === "consent") {
        await interaction.reply({ content: `You have ${parts[1]} consent.` });
        await Persistence.createConsent({ userId: interaction.user.id, status: parts[1] });
      }
    }
  }

  async onConsentChange(consent) {
    const voiceMembers = await this.getVoiceMembers();
    const member = voiceMembers.find((member) => consent.userId === member.id);

    // Update consent message buttons
    const consentMenu = await this.getConsentMenu(member);
    consentMenu.edit({
      components: this.getConsentComponents(consent),
    });

    // Mute or unmute user based on consent change
    if (member && member.voice) {
      const shouldBeMuted = consent.status !== "granted";
      const isMuted = member.voice.serverMute;

      if (shouldBeMuted && !isMuted) {
        this.mutedByMe.push(member.id);
        await member.voice.setMute(true);
      } else if (!shouldBeMuted && isMuted && this.mutedByMe.includes(member.id)) {
        this.mutedByMe = this.mutedByMe.filter((id) => id !== member.id);
        await member.voice.setMute(false);
      }
    }
  }
  // #endregion

  // #region Menu Builders
  async buildConsentMenu(userResolvable) {
    const user = await this.client.users.resolve(userResolvable);

    let dmChannel = user.dmChannel;
    if (!user.dmChannel) dmChannel = await user.createDM();

    const consent = await Persistence.getConsent(user.id);

    const consentMenu = await this.getConsentMenu(user);
    if (consentMenu) return;

    await dmChannel.send({
      content: this.getConsentMenuText(),
      components: this.getConsentComponents(consent),
    });
  }
  // #endregion
  // #region Utiltity
  async getVoiceMembers() {
    const joinableChannels = await this.getJoinableChannels();
    return joinableChannels.flatMap((channel) => channel.members).filter((member) => this.isNotMe(member));
  }

  getConsentMenuText() {
    return (
      `Hi! I'm a bot that records users in voice channels in ${this.server.name}.\n` +
      `Do you consent to being recorded?`
    );
  }

  getConsentComponents(consent) {
    return [
      new ActionRowBuilder().addComponents(
        new ButtonBuilder()
          .setLabel("Grant consent")
          .setCustomId("consent.granted")
          .setStyle(ButtonStyle.Primary)
          .setDisabled(consent ? consent.status === "granted" : false),
        new ButtonBuilder()
          .setLabel("Revoke consent")
          .setCustomId("consent.revoked")
          .setStyle(ButtonStyle.Danger)
          .setDisabled(consent ? consent.status !== "granted" : false),
      ),
    ];
  }

  _isConsentMenu(message) {
    return message.content === this.getConsentMenuText();
  }

  async getConsentMenu(userResolvable) {
    const user = await this.client.users.resolve(userResolvable);

    let dmChannel = user.dmChannel;
    if (!user.dmChannel) dmChannel = await user.createDM();

    // search cache first
    let consentMenu = dmChannel.messages.cache.find(this.isConsentMenu);
    if (consentMenu) return consentMenu;

    const allMessages = await dmChannel.messages.fetch();
    consentMenu = allMessages.find(this.isConsentMenu);
    if (consentMenu) return consentMenu;

    return null;
  }
  // #endregion
}

module.exports = new UserChannel();
